C51 COMPILER V9.52.0.0   BLUETOOTH_MAIN                                                    12/10/2017 14:33:29 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE BLUETOOTH_MAIN
OBJECT MODULE PLACED IN bluetooth_main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE bluetooth_main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*
   2            名称：蓝牙串口通信显示在lcd上
   3            日期：2017.12.08
   4            修改：初版
   5            内容：连接好串口或者usb转串口至电脑，下载该程序，打开电源
   6                  打开串口调试程序，将波特率设置为9600，无奇偶校验
   7                  晶振11.0592MHz，发送和接收使用的格式相同，如都使用
   8                  字符型格式，在发送框输入 hello ，在接收框中同样可以
   9                          看到相同字符，说明设置和通信正确,讲SBUF收到的数据
  10                          显示到LCD上
  11           */
  12          #include<reg52.h>
  13          #include "bluetooth.h"
  14          #include <intrins.h>
  15          #include <stdio.h>
  16          #include <math.h>
  17          #include <string.h>
  18          
  19          /************************************************
  20                          定义串口使用接口信息
  21          *************************************************/
  22          typedef struct serial_var{
  23                          unsigned char recData;                             //读取SBUF存储的数据
  24                          unsigned char serial_rec_ok;               //串口接收成功标志
  25                          unsigned char serial_send_ok;              //串口发生成功标志
  26          
  27          }serial_var_t;
  28          
  29          serial_var_t  serial={'\0', 0, 1};
  30          
  31          sbit TX_LED = P1^6;
  32          sbit RX_LED = P1^7;
  33          sbit RELAY = P1^0;
  34          
  35          /************************************************
  36                          定义LCD12864使用接口信息
  37          *************************************************/
  38          sbit RS  = P2^4;
  39          sbit WRD = P2^5;
  40          sbit E   = P2^6;
  41          sbit PSB = P2^1;
  42          sbit RES = P2^3;
  43          sbit BUSY_FLAG = P0^7;
  44          #define LCD_DATA P0
  45          
  46          //unsigned char code pic2[];
  47          //unsigned char code pic3[];
  48          
  49          unsigned char code IC_DAT[]={
  50          "上海浩豚电子科技"  
  51          "单片机开发板系列"
  52          "中文字库测试程序"
  53          "恭喜发财身体健康"
  54          };
  55          unsigned char code IC_DAT2[]={
C51 COMPILER V9.52.0.0   BLUETOOTH_MAIN                                                    12/10/2017 14:33:29 PAGE 2   

  56          "海纳百川宽容为先"
  57          "欲成大业诚信为先"
  58          "游弋商海济世为先"
  59          "人立于世守法为先"
  60          };
  61          
  62          unsigned char temp;
  63          #define LOG serial_write_str
  64          
  65          
  66          /************************************************
  67                                          主程序
  68          *************************************************/
  69          void main()
  70          {
  71   1              init_graphic();            //调用LCD显示图片(扩展)初始化程序 
  72   1              DisplayGraphic(pic2);  //显示图片2
  73   1              delayms(200);
  74   1              
  75   1      //串口初始化
  76   1              RELAY = 0;
  77   1              TX_LED = 1;
  78   1              RX_LED = 1;
  79   1              serial_init();
  80   1                      
  81   1              init_lcd_characters();                   //调用LCD字库初始化程序
  82   1          delay(100);            //大于100uS的延时程序 
  83   1          lcd_mesg(IC_DAT2);     //显示中文汉字2
  84   1          delayms(200);
  85   1              
  86   1              while(1){
  87   2                      if(serial.serial_rec_ok ==1){
  88   3                              show_serial_TRX('R');
  89   3                              temp = serial_read();
  90   3                                                              
  91   3                              switch(temp){
  92   4                                      case 0x61: //a
  93   4                                              init_lcd_characters();  //调用LCD字库初始化程序
  94   4                                              delay(100);            //大于100uS的延时程序
  95   4                                              lcd_mesg(IC_DAT);      //显示中文汉字1
  96   4                                              delayms(200);
  97   4                                              break;
  98   4                                      case 0x62: //b
  99   4                                              init_lcd_characters();  //调用LCD字库初始化程序
 100   4                                              delay(100);            //大于100uS的延时程序
 101   4                                              clear_screen();
 102   4                                              delayms(200);
 103   4                                              break;
 104   4                                      case 0x63: //c
 105   4                                              init_lcd_characters();  //调用LCD字库初始化程序
 106   4                                              delay(100);            //大于100uS的延时程序
 107   4                                              lcdDisplayString(1,0,"冯海涛LOVE杨晶晶");
 108   4                                              delayms(200);
 109   4                                              break;
 110   4                                      case 0x64: //d
 111   4                                              init_lcd_characters();  //调用LCD字库初始化程序
 112   4                                              delay(100);            //大于100uS的延时程序
 113   4                                              lcdDisplayString(3,0,"蓝牙打开. . .");
 114   4                                              delayms(200);
 115   4                                              break;
 116   4                                      case 0x65: //e
 117   4                                              init_lcd_characters();  //调用LCD字库初始化程序
C51 COMPILER V9.52.0.0   BLUETOOTH_MAIN                                                    12/10/2017 14:33:29 PAGE 3   

 118   4                                              delay(100);            //大于100uS的延时程序
 119   4                                              lcdDisplayString(2,1,"abcdefghijklmnopqrstuvw");
 120   4                                              delayms(200);
 121   4                                              break;
 122   4                                      case 0x66: //f
 123   4                                              RELAY = ~RELAY;
 124   4                                              break;
 125   4                                      case 0x67: //g
 126   4                                              
 127   4                                              break;                                  
 128   4                              }
 129   3                                              
 130   3                      }else if(serial.serial_rec_ok == 0){
 131   3                              show_serial_TRX('R');
 132   3                      }
 133   2                      
 134   2                      if(serial.serial_send_ok == 1){
 135   3                              
 136   3                      }
 137   2                      
 138   2                      
 139   2                              
 140   2              }
 141   1      }
 142          
 143          
 144          /************************************************
 145                                    串口初始化
 146          *************************************************/
 147          void serial_init()
 148          {
 149   1              SCON = 0x50;    /*scon 模式1,10位数据传输方式，双机通信，允许接收外部串口数据 */
 150   1              TMOD |=0x20;    /*TMOD 定时器1，模式2,8位自动重载*/
 151   1              TH1 = 0xFD;     /*TH1 设定重载值， 波特率9600,11.0592M晶振*/
 152   1              TR1 = 1;                /*定时器设置好，打开定时器*/
 153   1              EA = 1;                 /*打开总中断*/
 154   1              ES =1;                  /*打开串口中断*/
 155   1              ET1=0;                  /*因为采用8位重载模式，不用中断函数设置重载值*/
 156   1      }
 157          
 158          /**************************************************
 159                                  串口接收发送显示led
 160          @param type 显示类型
 161          **************************************************/
 162          void show_serial_TRX(unsigned char type){
 163   1              delay(20);
 164   1              if(type == 'T'){
 165   2                      TX_LED = ~TX_LED;
 166   2              }else if (type == 'R'){
 167   2                      RX_LED = ~RX_LED;
 168   2              }
 169   1      }
 170          
 171          
 172          /************************************************
 173                                  串口中断程序
 174          *************************************************/
 175           void serial_interrupt(void) interrupt 4
 176           {
 177   1      
 178   1              if(RI)
 179   1              {
C51 COMPILER V9.52.0.0   BLUETOOTH_MAIN                                                    12/10/2017 14:33:29 PAGE 4   

 180   2                              RI =0; /*RI 当接收到一帧完成，RI变为1，触发中断，需软件恢复0*/
 181   2                              serial.recData = SBUF; /*读取接收缓存寄存器的值*/
 182   2                              serial.serial_rec_ok = 1; /*接收成功标志*/
 183   2                              if(serial.serial_rec_ok==1) /*把接收到的值再发回去，如电脑*/
 184   2                              {
 185   3                                      serial_write(serial.recData);
 186   3                              }
 187   2                              
 188   2              }
 189   1              if(TI)
 190   1              {
 191   2                              TI=0; /*TI 当发送一帧完成，TI变为1，触发中断，需软件恢复0*/
 192   2                              serial.serial_send_ok = 1; /*发送成功标志*/
 193   2                              
 194   2              }
 195   1              
 196   1       }
 197          
 198          /************************************************
 199          @fuc 从串口种读取1字节的数据返回
 200          @return 读取的 unsigned char 类型数据
 201          此函数只做拿取数据，调用前先判断是否接收数据完成
 202          *************************************************/
 203          unsigned char serial_read()
 204          {
 205   1              serial.serial_rec_ok = 0;
 206   1              return serial.recData;
 207   1      
 208   1      }
 209          
 210          /************************************************
 211          @func 写1个字节数据到串口
 212          @param value unsigned char 类型数据
 213          *************************************************/
 214          void serial_write(unsigned char value)
 215          {
 216   1              serial.serial_send_ok = 0;
 217   1              SBUF = value;   
 218   1      }
 219          
 220          /************************************************
 221          @func 发送1个字符串
 222          @param str 字符串地址，确保以'\0'结尾
 223          *************************************************/
 224          void serial_write_str(unsigned char *str)
 225          {
 226   1              while(*str)
 227   1              {
 228   2                      while(!serial.serial_send_ok); //等待前一个字符发送完成才能发送下一字节
 229   2                      serial_write(*str++);
 230   2      
 231   2              }
 232   1      
 233   1      }
 234          
 235          /*****************************************************************************
 236          ----------------------- LCD显示部分-------------------------------------------
 237          ******************************************************************************/
 238          /************************************************
 239                                  LCD初始化字库
 240          *************************************************/
 241          void init_lcd_characters(void)
C51 COMPILER V9.52.0.0   BLUETOOTH_MAIN                                                    12/10/2017 14:33:29 PAGE 5   

 242          {
 243   1              delay(40);    //大于40ms的延时程序
 244   1              PSB=1;            //设置为8BIT并口工作模式
 245   1              delay(1);         //延时
 246   1              RES=0;            //复位
 247   1              delay(1);         //延时
 248   1              RES=1;            //拉高复位
 249   1              delay(10);
 250   1              TransferData(0x30,0); //  RE=0
 251   1              delay(100);
 252   1              TransferData(0x30,0); //功能设定 0011 0000
 253   1              delay(37);
 254   1              TransferData(0x08,0); //显示控制 0000 1000
 255   1              delay(100);
 256   1              TransferData(0x10,0); //光标控制 0001 0000
 257   1              delay(100);
 258   1              TransferData(0x0c,0); //显示开   0000 1100
 259   1              delay(100);
 260   1              TransferData(0x01,0); //清屏     0000 0001
 261   1              delay(10);
 262   1              TransferData(0x06,0); //Enry Mode Set ,光标从右向左加1位移动 0000 0110
 263   1              delay(100);
 264   1      }
 265          
 266          /************************************************
 267                                  液晶初始化--图形
 268          *************************************************/
 269          void init_graphic(void)
 270          {
 271   1        delay(40);
 272   1        PSB=1;      //设置为8BIT并口工作模式
 273   1        delay(1);             
 274   1        RES=0;
 275   1        delay(1);
 276   1        RES=1;
 277   1        delay(10);
 278   1      
 279   1        TransferData(0x36,0);  //RE =1
 280   1        delay(100);
 281   1        TransferData(0x36,0);
 282   1        delay(37);
 283   1        TransferData(0x3E,0);  //DL 8bits RE=1，G=1
 284   1        delay(100);
 285   1        TransferData(0x01,0);  //clear Screen
 286   1        delay(100);
 287   1      }
 288          
 289          /************************************************
 290                             LCD显示中文汉字
 291          *************************************************/
 292          void lcd_mesg(unsigned char code *adder1)
 293          {
 294   1               unsigned char i;
 295   1               unsigned char len;
 296   1               len = strlen(adder1);
 297   1               TransferData(0x80,0); //设置图形显示RAM地址
 298   1               for(i=0;i<32;i++){
 299   2                      TransferData(*adder1,1);
 300   2                      adder1++;
 301   2               }
 302   1      
 303   1               TransferData(0x90,0); //设置图形显示RAM地址
C51 COMPILER V9.52.0.0   BLUETOOTH_MAIN                                                    12/10/2017 14:33:29 PAGE 6   

 304   1               delay(100);
 305   1      
 306   1               for(i=0;i<32;i++){
 307   2                      TransferData(*adder1,1);
 308   2                        adder1++;
 309   2               }
 310   1      }
 311          
 312          /*************************************************
 313          在指定行和列显示汉字
 314          x-行数值 0-3 12864可以显示4行汉字
 315          y-列数值0-7  12864可以显示8列汉字
 316          一个地址对应一个汉字
 317          0x80 - 0x87
 318          0x90 - 0x97
 319          0x88 - 0x8F
 320          0x98 - 0x9F
 321          可以显示32个汉字，64个字符
 322          ***************************************************/
 323          void lcdDisplayString(unsigned char x, unsigned char y, unsigned char *str)
 324          {
 325   1              unsigned char row,n=0;
 326   1      
 327   1              TransferData(0x30,0);  //基本指令
 328   1              TransferData(0x06,0);  //地址计数器自动累加，光标右移
 329   1              if(x==0){
 330   2                      row = 0x80;
 331   2              }else if(x == 1){
 332   2                      row = 0x90;
 333   2              }else if(x == 2){
 334   2                      row = 0x88;
 335   2              }else if(x == 3){
 336   2                      row = 0x98;
 337   2              }
 338   1              TransferData((row+y),0);
 339   1              while(*str != '\0'){
 340   2                      TransferData(*str,1);
 341   2                      str++;
 342   2                      n++;
 343   2                      
 344   2                      if((n+y*2) == 16) //写满一行，继续写第二行
 345   2                      {
 346   3                              if(x==0){
 347   4                                      TransferData(0x90,0);
 348   4                              }else if(x==1){
 349   4                                      TransferData(0x88,0);
 350   4                              }else if(x==2){
 351   4                                      TransferData(0x98,0);
 352   4                              }
 353   3                      }else if((n+y*2) == 32) //写满第二行，继续第三行
 354   2                      {
 355   3                              if(x==0){
 356   4                                      TransferData(0x88,0);
 357   4                              }else if(x==1){
 358   4                                      TransferData(0x98,0);
 359   4                              }
 360   3                      }else if((n+y*2) == 48)  //写满第三行，继续第四行
 361   2                      {
 362   3                              if(x==0){
 363   4                                      TransferData(0x98,0);
 364   4                              }
 365   3                      }       
C51 COMPILER V9.52.0.0   BLUETOOTH_MAIN                                                    12/10/2017 14:33:29 PAGE 7   

 366   2              }
 367   1              
 368   1      }
 369          
 370          /***********************************************
 371                                                          清屏
 372          ************************************************/
 373          void clear_screen()
 374          {
 375   1          TransferData(0x01,0);
 376   1                      TransferData(0x00,0);
 377   1      }
 378          
 379          /************************************************
 380          @func 传送数据或者命令
 381          @param DI =0 传送命令, =1 传送数据
 382          RS=L RW=L，E=H ，写指令
 383          RS=H RW=L, E=H , 写数据
 384          *************************************************/
 385          void TransferData(char data1,bit DI)
 386          {
 387   1              lcd_check_busy();
 388   1              WRD=0;
 389   1              RS=DI;
 390   1              delay(1);
 391   1              LCD_DATA=data1;
 392   1              E=1; //E 1-0所存有效
 393   1              delay(1);
 394   1              E=0;
 395   1      }
 396          
 397          /************************************************
 398            延时 10xn毫秒程序
 399          *************************************************/
 400          void delayms(unsigned int n)
 401          {
 402   1              unsigned int i,j;
 403   1              for(i=0;i<n;i++){
 404   2                      for(j=0;j<2000;j++);
 405   2              }       
 406   1      }
 407          
 408          /************************************************
 409                  延时程序
 410          *************************************************/
 411          void delay(unsigned int m)
 412          {
 413   1              unsigned int i,j;
 414   1              for(i=0;i<m;i++){
 415   2                      for(j=0;j<10;j++);
 416   2              }
 417   1      
 418   1      }
 419          
 420          /************************************************
 421                                  图像显示
 422          *************************************************/
 423          void DisplayGraphic(unsigned char code *adder)
 424          {
 425   1              int i,j;
 426   1              /************显示上半屏内容设置***********/
 427   1              for(i=0;i<32;i++){    //32行
C51 COMPILER V9.52.0.0   BLUETOOTH_MAIN                                                    12/10/2017 14:33:29 PAGE 8   

 428   2                      TransferData((0x80+i),0); //set vertical adder
 429   2                      TransferData(0x80,0);     //set horizontal adder
 430   2                      for(j=0;j<16;j++){ //16个字节 一个char类型8位 128bit
 431   3                              TransferData(*adder,1);
 432   3                              adder++;
 433   3                      }
 434   2              }
 435   1              /*************显示下半屏内容设置*********/
 436   1              for(i=0;i<32;i++){
 437   2                      TransferData((0x80+i),0); //set vertical adder
 438   2                      TransferData(0x88,0);     //set horizontal adder
 439   2                      for(j=0;j<16;j++){
 440   3                              TransferData(*adder,1);
 441   3                              adder++;
 442   3                      }
 443   2              }
 444   1      }
 445          
 446          /************************************************
 447                                                                          LCD忙检测
 448          *************************************************/
 449          void lcd_check_busy()
 450          {
 451   1                      LCD_DATA = 0xff;
 452   1                      RS = 0;
 453   1                      WRD = 1;
 454   1                      E = 1;
 455   1                      while(BUSY_FLAG);
 456   1                      E = 0;
 457   1      }
 458          
 459          
 460          
 461          
 462          
 463          
 464          
 465          
 466          
 467          
 468          
 469          
 470          
 471          
 472          
 473          
 474          
 475          
 476          
 477          
 478          
 479          
 480          
 481          
 482          
 483          
 484          
 485          
 486          
 487          
 488          
 489          
C51 COMPILER V9.52.0.0   BLUETOOTH_MAIN                                                    12/10/2017 14:33:29 PAGE 9   

 490          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1212    ----
   CONSTANT SIZE    =   2233    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4      22
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
