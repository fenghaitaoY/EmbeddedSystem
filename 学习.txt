Gson　

fromJson() :实现反序列化
toJson() : 实现序列化

基本数据类型生成
Gson　gson = new Gson();
String jsonNumber = gson.toJson(100);
String jsonBoolean = gson.toJson(false);
String jsonString = gson.toJson("String");

对于普通Ｊａｖａ类
public class User{
	public String name;
	public int age;
}

生成JSON
Gson gson = new Gson();
User user = new User("Sunny", 24);
String jsonObject = gson.toJson(user); //{"name":"Sunny", "age":24}

解析JSON
Gson gson = new Gson();
String jsonString = "{\"name\":\"Sunny\", \"age\":24}";
User user = gson.fromJson(jsonString, User.class);
//解析对象　参数对应解析类

泛型
数组
String[] strings = gson.fromJson(jsonArray, String[].class);

List
Gson 提供TypeToken来实现对泛型的支持，　TypeToken帮助我们捕获像List这样的泛型信息，
Java编译器会把捕获到的泛型信息编译到这个匿名内部类里，　然后运行时就可以被getType（）方法用反射API提取到, 也就是转成.class
List<String> stringList = gson.fromJson(jsonArray, new TypeToken<List<String>>(){}.getType())

注解

@Expose　注解：　区分实体中不想被序列化的属性
@SerializeName　注解：定义属性序列化后的名称


Gson解析复杂JSON数据
1,JsonParse 解析类  getAsJsonObject 和getAsJsonArray
2,JsonElement 抽象类，代表JSON串中的某一个元素


泛型类
	List Set Map

public class Gengeric<T>{ //T E K V 表示泛型
	private T key; //类型由T决定

}


注解

自定义注解
元注解
@Target({ElementType.METHOD,ElementType.TYPE})　
//注解作用域，　
//METHOD-方法声明, CONSTRUCTOR-构造方法声明, FIELD-字段声明, LOCAL_VARIABLE-局部变量声明, PACKAGE－包声明，　PARAMETER-参数声明, TYPE-类接口

@Retention(RetentionPolicy.RUNTIME)
//生命周期
//RUNTIME－运行时存在，　可以通过反射读取，　SOURCE- 源码显示，编译时丢失，　CLASS-编译记录到class中，　运行时忽略

@Inherited　
//标识性的元注解，　允许子注解继承它

@Documented　
//生成javadoc时包含注解

public @interface Description {
    String desc(); //非方法　只是一个成员变量
    String author();
    int age() default 18; //成员变量可以用default指定默认值
}

１，成员类型受限制，　合法的类型包括基本数据类型，String Class　Annotation Enumeration
２，如果注解只有一个成员，　则成员取名为value()，　使用时可以忽略成员名和赋值号
３，注解类可以没有成员，没有成员的注解称为标识注解

使用自定义注解：
@<注解名>(<成员名１>＝<成员值１>，　<成员名２>＝<成员值２>,...)

@Description(desc="fht", author="hhh", age=11)
public String color(){
	return "red";
}


解析注解：
通过反射获取类，函数或成员上的运行时注解信息，从而实现动态控制程序运行时的逻辑

类解析：
Class class = Class.forName("com.test.child");
boolean isExist = class.isAnnotationPresent(Description.class);
if(isExist){
	Description d = class.getAnnotation(Description.class);
	System.out.println(d.value());
}

方法解析
Method[] ms = class.getMethods();
for(Method m: ms){
	boolean isExist = m.isAnnotation(Description.class);
	if(isExist){
		Description d = m.getAnnotation(Description.class);
		System.out.println(d.value());
	}
}



@Override 覆盖
@Deprecated 弃用

按照运行时划分：
源码注解－＞编译时注解－＞运行时注解
源码注解：　只在源码中存在，　编译成.class文件不存在
编译时注解：在源码和.class文件中存在，　像@Override/@Deprecated/@SuppressWarnings
运行时注解：在运行时还起作用，甚至影响运行逻辑的注解　@Autowired


OkHttp 
在OKHttp，每次网络请求就是一个Request，我们在Request里填写我们需要的url，header等其他参数，
再通过Request构造出Call，Call内部去请求服务器，得到回复，并将结果告诉调用者。同时okhttp提供了同步和异步两种方式进行网络操作

Get 请求
OkHttpClient client = new OkHttpClient();
//创建Request
Request request = new Request.Builder()
					.get()
					.url(url)
					.build();

通过client发起请求
client.newCall(request).enqueue(new Callback(){
	@Override
	public void onFailure(Call call , IOException e){

	}

	@Override
	public void onResponse(Call call, Response response) throws IOException{
		if(response.isSuccessful()){
			//String str = response.body().string();
		}
	}
})


Post
From　表单形式
	OkHttpClient client = new OkHttpClient();
	RequestBody body = new FormBody.Builder().add("usename", "xiaoyi").build();
	Request request = new Request.Builder()
						.post(body)
						.url(url)
						.build();
	client.newCall(request).enqueue(new Callback() { });

JSON 参数形式
	OkHttpClient client = new OkHttpClient();
	RequestBody body = RequestBody.create(MediaType.parse("application/json; charset=utf-8"), json);
	Request request = new Request.Builder()
						.post(body)
						.url(url)
						.build();
	client.newCall(request).enqueue(new Callback(){ });



BLE 

profile框架
每个attribute属性被UUID唯一标识，　UUID是标准128-bit格式的ID用来唯一标识信息，　
特征Characteristics　一个characteristics包含一个单独的value　和 多个用来描述characteristic值的descriptors，　一个characteristics可以被认为是一种类型，类似一个类

描述符descriptor　用来描述一个characteristic的值
服务service　是characteristic的集合



			|------>Name Title
			|
			|			
Profile------------>Service
			|
			|					|-------->Characteristic         |---->value[]
			|					|								 |
			|----->Service--------------->Characteristic ------------->Descriptor
								|								 |
								|-------->Characteristic         |---->Descriptor


通用属性规范GATT GATTProfile是一个 通用规范 用于在BLE链路 发送和接收 被称为属性attributes的数据片
蓝牙SIG定义了许多profile用于低功耗设备，　Profile是一个规范，　规范了设备如何工作在一个特定的应用场景；


主从通信透传模块
BLE 主透传协议模块,简称MTTM ,可以工作在透传模式TTM或者指令模式CM

MTTM上电后，　处于待机模式SBM,此时处于空闲状态, 无睡眠, 需要用户通过ＡＴ指令控制模块连接从设备, 在成功与从设备建立链接后，　MTTM会自动查找从设备的透传通道，
如果从设备属于ble从透传协议模块(简称STTM), MTTM默认进入透传模式, 否则默认进入指令模式

透传模式下，　用户ＣＰＵ可以通过模块的通用串口与ＳＴＴＭ进行双向通讯，　从MTTM串口输入的数据转发到STTM，　并从STTM的串口输出; 从　从透传协议模块输入的数据将转发到
主透传协议模块，　并从主透传协议模块串口输出，从而实现透明传输功能


MCU <--tx rx-> MTTM      <----->  STTM <--tx rx--> MCU

透传中的数据格式也是profile　结构：
１，　profile　
	一个标准的通信协议，　存在从机中，　蓝牙组织规定了一些标准的profile，　列如　HID OVER GATT，　防丢器　,心率计等，　每个profile中包含多个ｓｅｒｖｉｃｅ，
	每个ｓｅｒｖｉｃｅ代表从机的一种能力
２，service
	可以理解为一个服务，　在ble从机中，　通过有多个服务，　例如电量信息服务，　系统信息服务等，　每个ｓｅｒｖｉｃｅ中包含多个characteristic特征值, 
	每个characteristic特征值才是ble通信的主题，　比如当前电量是80%, 所以会通过电量的charactic特征值存在从机的profile里，　这样主机就可以通过
	characteristic来读取这个数据
３，characteristic
	ble主从机的通信均是通过characteristic来实现, 可以理解为一个标签, 通过这个标签可以获取或者写入想要的内容
4, UUID
	统一识别码，　上面提到的service和characteristic，　都需要一个唯一的uuid来标识

每个从机都会有一个叫做profile的东西存在，不管是simpleprofile，还是标准的防丢器profile，　他们都是由一系列service组成，　然后每个service包含了多个characteristic, 主机和从机之间的通信，　均是通过characteristic实现

